module process (
    input clk,  // clock
    input rst,  // reset
    input start,
    input joystickaUp,
    input joystickaDown,
    input joystickaLeft,
    input joystickaRight,
    input joystickbUp,
    input joystickbDown,
    input joystickbLeft,
    input joystickbRight,
    output r0,
    output g0,
    output bl0,
    output r1,
    output g1,
    output bl1,
    output latch,
    output blank,
    output rowsel[4],
    output debug[8],
    output dclk
  ) {
  
  const SPEED = 3; //HOW FAST TO RUN EACH ONE
  dff gclk[32](.clk(clk), .rst(rst), #INIT(0)); //GAME CLOCK
  
  const GROWTH = 4;
  const APPLE = 10;
  const COLLIDE = 5;
  const KILL = 15;
  
  //CURRENT ROW AND COL
  
  //SNAKES
  dff arow[64][7](.clk(gclk.q[SPEED]));
  dff acol[64][7](.clk(gclk.q[SPEED]));
  dff brow[64][7](.clk(gclk.q[SPEED]));
  dff bcol[64][7](.clk(gclk.q[SPEED]));
  
  //SNAKE 1 BIT CHECKERS
  dff atop[64](.clk(gclk.q[SPEED]), .rst(rst));
  dff abot[64](.clk(gclk.q[SPEED]), .rst(rst));
  dff btop[64](.clk(gclk.q[SPEED]), .rst(rst));
  dff bbot[64](.clk(gclk.q[SPEED]), .rst(rst));
  
  //SNAKE SIZES
  dff alen[6](.clk(gclk.q[SPEED]));
  dff blen[6](.clk(gclk.q[SPEED]));
  
  //SNAKE DEATHS
  dff alethal[1](.clk(gclk.q[SPEED]), .rst(rst));
  dff blethal[1](.clk(gclk.q[SPEED]), .rst(rst));
  
  //APPLE COORDINATES
  dff approw[7](.clk(gclk.q[SPEED]));
  dff appcol[7](.clk(gclk.q[SPEED]));
  
  //ELEMENTS
  dff walltop(.clk(gclk.q[SPEED]), .rst(rst));
  dff wallbot(.clk(gclk.q[SPEED]), .rst(rst));
  dff appletop(.clk(gclk.q[SPEED]), .rst(rst));
  dff applebot(.clk(gclk.q[SPEED]), .rst(rst));
  
  //DIRECTIONS
  dff adirection[4](.clk(clk), .rst(rst), #INIT(b0100)); //0 = LEFT, 1 = UP, 2 = RIGHT, 3 = DOWN so {0011} is up and left diagonally
  dff bdirection[4](.clk(clk), .rst(rst), #INIT(b0001)); //0 = LEFT, 1 = UP, 2 = RIGHT, 3 = DOWN
  
  dff lastaDirection[2](.clk(gclk.q[SPEED]), .rst(rst), #INIT(b10)); // 0 = LEFT, 1 = UP, 2 = RIGHT, 3 = DOWN
  dff lastbDirection[2](.clk(gclk.q[SPEED]), .rst(rst), #INIT(b00));
  
  //SCORE ELEMENTS
  dff ascore[8](.clk(gclk.q[SPEED]), .rst(rst));
  dff bscore[8](.clk(gclk.q[SPEED]), .rst(rst));
  dff aaddscore[8](.clk(gclk.q[SPEED]), .rst(rst));
  dff baddscore[8](.clk(gclk.q[SPEED]), .rst(rst));
  dff aapplescore[8](.clk(gclk.q[SPEED]), .rst(rst));
  dff bapplescore[8](.clk(gclk.q[SPEED]), .rst(rst));
  dff asubscore[8](.clk(gclk.q[SPEED]), .rst(rst));
  dff bsubscore[8](.clk(gclk.q[SPEED]), .rst(rst));
  
  //VAR 
  dff counter[32](.clk(gclk.q[SPEED]));
  var count;
  dff move(.clk(gclk.q[SPEED]));
  sig adir[2];
  sig bdir[2];
  sig row[7];
  sig col[7];
  sig randrow[7];
  sig randcol[7];
  
  //MODULES
  control control;
  random random;
  
  always {
    gclk.d = gclk.q + 1;
    counter.d = counter.q + 1;
    
    
    debug[7:0] = arow.q[0];
   
    /*
    GAME TIME CONTROL
    */
    if (counter.q == 200000){
      move.d = 1;
      counter.d = 0;
    }
    else{
      move.d = 0;
    }
    
    control.clk = gclk.q[SPEED];
    control.rst = rst;
    row = control.rowOut;
    col = control.colOut;
    
    random.clk = gclk.q[SPEED];
    random.rst = rst;
    randrow = random.randrow;
    randcol = random.randcol;
    
    adirection.d = adirection.q;
    bdirection.d = bdirection.q;
    
    alethal.d = alethal.q;
    blethal.d = blethal.q;

    //JOYSTICK INPUT 
    if(~joystickaLeft | ~joystickaUp | ~joystickaRight | ~joystickaDown){
      adirection.d[0] = ~joystickaLeft;
      adirection.d[1] = ~joystickaUp;
      adirection.d[2] = ~joystickaRight;
      adirection.d[3] = ~joystickaDown;
    }
    
    
    /*****
    MOVE AND COLLIDE DETECTION BEGIN
    *****/
    if (start){ //INITIALISE AFTER A DEATH
      counter.d = 0;
      arow.d[0] = 15;
      acol.d[0] = 20;
      brow.d[0] = 16;
      bcol.d[0] = 43;
      for(count = 1; count < 64; count++){
        arow.d[count] = 0;
        acol.d[count] = 0;
        brow.d[count] = 0;
        bcol.d[count] = 0;
      }
      adirection.d = b0100;
      bdirection.d = b0001;
      alen.d = 8;
      blen.d = 8;
      alethal.d = 0;
      blethal.d = 0;
      approw.d = randrow;
      appcol.d = randcol;
      lastaDirection.d = 2;
      lastbDirection.d = 0;
      move.d = 1;
    }
    else if(~alethal.q && ~blethal.q){
      if (move.q){
        for(count = 1; count < 64; count++){
          //MOVE A BODY ELEMENTS
          if(alen.q > count){
            arow.d[count] = arow.q[count - 1];
            acol.d[count] = acol.q[count - 1];
          }
          //MOVE B BODY ELEMENTS
          if(blen.q > count){
            brow.d[count] = brow.q[count - 1];
            bcol.d[count] = bcol.q[count - 1];
          }
        }
        
        //DEFINE A DIRECTION
        case(adirection.q){
          b0001: //SIDES
            if(lastaDirection.q != 2) adir = 0;
            else adir = 2;
          b0010: adir = 1;
            if(lastaDirection.q != 3) adir = 1;
            else adir = 3;
          b0100: adir = 2;
            if(lastaDirection.q != 0) adir = 2;
            else adir = 0;
          b1000: adir = 3;
            if(lastaDirection.q != 1) adir = 3;
            else adir = 1;
          b0011: //DIAGONALS
  				  if(lastaDirection.q == 0) adir = 1;
  				  else if(lastaDirection.q != 2) adir = 0;
  				  else if(lastaDirection.q != 3) adir = 1;
  				  else adir = lastaDirection.q;
          b0110:
  				  if(lastaDirection.q == 1) adir = 2;
  				  else if(lastaDirection.q != 3) adir = 1;
  				  else if(lastaDirection.q != 0) adir = 2;
  				  else adir = lastaDirection.q;
          b1100:
  				  if(lastaDirection.q == 2) adir = 3;
  				  else if(lastaDirection.q != 0) adir = 2;
  				  else if(lastaDirection.q != 1) adir = 3;
  				  else adir = lastaDirection.q;
          b1001:
  				  if(lastaDirection.q == 3) adir = 0;
  				  else if(lastaDirection.q != 1) adir = 3;
  				  else if(lastaDirection.q != 2) adir = 0;
  				  else adir = lastaDirection.q;
          default: adir = lastaDirection.q;
        }
        lastaDirection.d = adir;
        //MOVE A HEAD
        case(adir){
          0: acol.d[0] = acol.q[0] - 1;
          1: arow.d[0] = arow.q[0] - 1;
          2: acol.d[0] = acol.q[0] + 1;
          3: arow.d[0] = arow.q[0] + 1;
        }
        
        
        //DEFINE B DIRECTION
        case(bdirection.q){
          b0001: //SIDES
            if(lastbDirection.q != 2) bdir = 0;
            else bdir = 2;
          b0010: bdir = 1;
            if(lastbDirection.q != 3) bdir = 1;
            else bdir = 3;
          b0100: bdir = 2;
            if(lastbDirection.q != 0) bdir = 2;
            else bdir = 0;
          b1000: bdir = 3;
            if(lastbDirection.q != 1) bdir = 3;
            else bdir = 1;
          b0011: //DIAGONALS
            if(lastbDirection.q == 0) bdir = 1;
            else if(lastbDirection.q != 2) bdir = 0;
            else if(lastbDirection.q != 3) bdir = 1;
            else bdir = lastbDirection.q;
          b0110:
            if(lastbDirection.q == 1) bdir = 2;
            else if(lastbDirection.q != 3) bdir = 1;
            else if(lastbDirection.q != 0) bdir = 2;
            else bdir = lastbDirection.q;
          b1100:
            if(lastbDirection.q == 2) bdir = 3;
            else if(lastbDirection.q != 0) bdir = 2;
            else if(lastbDirection.q != 1) bdir = 3;
            else bdir = lastbDirection.q;
          b1001:
            if(lastbDirection.q == 3) bdir = 0;
            else if(lastbDirection.q != 1) bdir = 3;
            else if(lastbDirection.q != 2) bdir = 0;
            else bdir = lastbDirection.q;
          default: bdir = lastbDirection.q;
        }
        lastbDirection.d = bdir;
        //MOVE B HEAD
        case(bdir){
          0: bcol.d[0] = bcol.q[0] - 1;
          1: brow.d[0] = brow.q[0] - 1;
          2: bcol.d[0] = bcol.q[0] + 1;
          3: brow.d[0] = brow.q[0] + 1;
        }
        
        move.d = 0;
        
      }
      else{
        //CHECK A COLLIDE WITH APPLE
        if((arow.q[0] == approw.q) && (acol.q[0] == appcol.q)){
          approw.d = 0;
          appcol.d = 0;
          aapplescore.d = aapplescore.q + APPLE;
          if(alen.q < 64 - GROWTH){
            alen.d = alen.q + GROWTH;
          }
        }
        //CHECK A COLLIDE WITH BORDER
        else if ((arow.q[0] == 0) || (arow.q[0] == 31) || (acol.q[0] == 16) || (acol.q[0] == 47)){
          alethal.d = 1;
          asubscore.d = asubscore.q + COLLIDE;
        }
        //CHECK A COLLIDE WITH SELF
        else if ((|atop.q[63:1] & atop.q[0]) | (|abot.q[63:1] & abot.q[0])){
          alethal.d = 1;
          asubscore.d = asubscore.q + COLLIDE;
        }
        //CHECK A COLLIDE WITH B
        else if ((|btop.q[63:1] & atop.q[0]) | (|bbot.q[63:1] & abot.q[0])){
          alethal.d = 1;
          asubscore.d = asubscore.q + COLLIDE;
          baddscore.d = baddscore.q + KILL;
        }
        
        //CHECK B COLLIDE WITH APPLE
        if((brow.q[0] == approw.q) && (bcol.q[0] == appcol.q)){
          approw.d = 0;
          appcol.d = 0;
          bapplescore.d = bapplescore.q + APPLE;
          if(blen.q < 64 - GROWTH){
            blen.d = blen.q + GROWTH;
          }
        }
        //CHECK B COLLIDE WITH BORDER
        else if ((brow.q[0] == 0) || (brow.q[0] == 31) || (bcol.q[0] == 16) || (bcol.q[0] == 47)){
          blethal.d = 1;
          bsubscore.d = bsubscore.q + COLLIDE;
        }
        //CHECK B COLLIDE WITH SELF
        else if ((|btop.q[63:1] & btop.q[0]) | (|bbot.q[63:1] & bbot.q[0])){
          blethal.d = 1;
          bsubscore.d = bsubscore.q + COLLIDE;
        }
        //CHECK B COLLIDE WITH A
        else if ((|atop.q[63:1] & btop.q[0]) | (|abot.q[63:1] & bbot.q[0])){
          blethal.d = 1;
          bsubscore.d = bsubscore.q + COLLIDE;
          aaddscore.d = aaddscore.q + KILL;
        }
      }
    }
    /*****
    MOVE AND COLLIDE DETECTION END
    *****/
    
    /*****
    CHECK IF CURRENT ROW AND COLUMN IS ON A BORDER
    *****/
    walltop.d = (((row == 0) || (col == 16) || (col == 47)) && ((col <= 47) && (col >= 16)));
    wallbot.d = (((row + 16 == 31) || (col == 16) || (col == 47)) && ((col <= 47) && (col >= 16)));
    
    /*****
    CHECK IF CURRENT ROW AND COLUMN IS ON AN APPLE
    *****/
    appletop.d = (row == approw.q) & (col == appcol.q);
    applebot.d = (row + 16 == approw.q) & (col == appcol.q);
    
    /*****
    CHECK IF CURRENT ROW AND COLUMN IS ON A HEAD/BODY
    *****/
    for(count = 0; count < 64; count++){
      atop.d[count] = (row == arow.q[count]) & (col == acol.q[count]);
      abot.d[count] = (row + 16 == arow.q[count]) & (col == acol.q[count]);
      btop.d[count] = (row == brow.q[count]) & (col == bcol.q[count]);
      bbot.d[count] = (row + 16 == brow.q[count]) & (col == bcol.q[count]);
    }
    
    /*****
    DISPLAY CONTROLLER
    *****/
    if(col == 65) latch = 1;
    else latch = 0;
    
    if(col < 20 || col > 66) blank = 0;
    else blank = 1;
    
    if(col < 65){
      if(row == 0) rowsel = 15;
      else rowsel = row - 1;
    }
    else rowsel = row[3:0];
    
    dclk = ~gclk.q[SPEED];
    
    r0 = walltop.q || (|appletop.q);
    g0 = walltop.q || (|btop.q);
    bl0 = walltop.q || (|atop.q);
    r1 = wallbot.q || (|applebot.q);
    g1 = wallbot.q || (|bbot.q);
    bl1 = wallbot.q || (|abot.q);

  
  }
}
